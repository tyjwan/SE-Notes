# 并发综述

---

## 综述

-   三个核心问题：
    -   分工：合理的规划、拆解任务
    -   同步：任务之间有依赖
    -   互斥：程序数据的正确性，注意死锁

### 场景

-   CPU、内存、磁盘 I/O 等，三者之间速度差异较大

    -   CPU 增加缓存，均衡与内存的速度差异
    -   操作系统增加进程、线程，分时复用 CPU，均衡 CPU 与 I/O 的差异
    -   编译程序优化指令执行顺序，使缓存更加合理的应用

-   可见性：一个线程对共享变量的修改，另一个线程能立即看到；多核多缓存导致不可见性
-   原子性：一个或多个操作在 CPU 执行过程中不被终端的特性；CPU 时间切片带来的不可预期
-   有序性：程序命令的顺序执行；编译优化有可能打乱顺序

-   可见性、有序性的解决：
    -   volatile
    -   synchronized
    -   final
    -   Happens-Before
-   原子性的解决：锁，注意锁的设计，锁与被包含资源之间的对应关系

-   synchronized：管程，但无法解决死锁；需改进能够响应中断、支持超时、非阻塞获取锁；支持多个条件变量
-   lock 和 condition：可重入锁，能够响应中断、支持超时、非阻塞获取锁；支持多个条件变量
-   Semaphore:同一个锁计数
-   ReadWriteLock：读写锁，读多写少；小心读锁升级写锁的写法
-   StampedLock：写锁、悲观锁、乐观锁；不支持重入
-   CountDownLatch 主要用来解决一个线程等待多个线程的场景
-   CyclicBarrier 是一组线程之间互相等待

-   原子类：CAS，ABA 版本

对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。
