# Java核心面试知识点整理

***

## Java基础

### Java平台的理解

- 跨平台：书写一次，到处运行
- GC：自动垃圾回收，不用操心内存的分配和回收
- jre：Java运行环境，包含jvm和Java类库和其他一些模块
- jdk：jre的超集，提供更多的工具，提供编译器、各种诊断工具

### Java是解释执行还是编译执行

&ensp;&ensp;&ensp;&ensp;代码首先编译成字节码，jvm在编译成机器码后执行。但动态编译器（JIT）会将热点代码编译成机器码，这种属于编译执行。则Java有解释执行，也有编译执行。

### 对比Exception和Error

&ensp;&ensp;&ensp;&ensp;在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。

- Exception和Error都继承自Throwable，能被抛出或者捕获，异常处理机制的基本组成类型
- Exception是正常运行是可以预料到的意外情况，需要进行捕获，然后可以进行处理；属于可检查异常
- Error是正常情况下不太可能出现的意外情况，大部分会导致程序处于非正常、不可恢复的状态，不便也不需要进行捕获；属于不检查异常

### 运行时异常与一般异常有什么区别

&ensp;&ensp;&ensp;&ensp;运行时异常就是不检查异常，如越界、空指针；通常是编码可以避免的错误，具体根据需求来进行捕获，并不会在编译器强行要求

### 谈谈 final、finally、 finalize 有什么不同

- final是一个修饰符，可以修饰变量、方法、类；修饰变量表示变量不可变；修饰方法表示方法在子类中不可被重写；修饰类表示不可被继承
  - 多线程中常量用final修饰，可以表示线程安全，省却额外的同步开销、防御性拷贝
  - 可能有助于jvm将方法内联
- finally是异常处理相关，和try等一起使用，常用语资源的释放，如数据连接，锁等
- finalize类似C++的析构函数，也就是类销毁前进行特定资源的回收，当现在已经不推荐使用了，因为GC是不可预期的
  - try-with-resource、ref.Clean

### 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

&ensp;&ensp;&ensp;&ensp;主要区别是其引用对象可达性对垃圾回收的影响

- 强引用：
  - 只要有强引用指向某个对象，则这个对象不会被回收
- 软引用：
  - 在内存不足的情况下，被软引用指向的对象可能会被回收
  - 用于缓存
- 弱引用：
  - 不能避免被回收
  - 有对象则引用，没有则新建，用于缓存
- 幻象引用（虚引用）：
  - 不能通过它访问对象，提供对象被销毁后做某些事情的机制
  - 用于清理，监控对象的创建和销毁

### 理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别

&ensp;&ensp;&ensp;&ensp;String是Java中基础重要常用的类，它是一个不可变类，方法属性都是否final修饰了的。由于它的不可变性，其裁剪、拼接等操作都是使用copy-on-write，直接生成新的对象返回。而大量的裁剪、拼接操作生成大量对象，对应用的性能产生明显的影响，所有后面stringBuffer和StringBuilder是为了解决这个问题而出现的。

&ensp;&ensp;&ensp;&ensp;stringBuffer和StringBuilder都是通过append或者add函数添加字符串到已有字符串末尾。而StringBuffer是线程安全的，StringBuilder不是线程安全的。没有线程安全的需要的话就使用StringBuilder，反之使用StringBuffer，由于线程安全需要加锁，所有性能稍差。

#### 扩展

- stringBuffer和StringBuilder初始大小默认是16，开始可自行指定大小，避免多次扩容带来的开销
- jvm非静态拼接能自动转StringBuilder
- String的演进：char存储--6：压缩字符串，但存在bug后移除--9：byte加编码coder（需要进行明确的编码？）

### 谈谈 Java 反射机制，动态代理是基于什么原理

- 反射是Java提供基础功能，赋予程序在运行时自省的能力。直接操作类和对象，获取类定义、方法、属性、调用方法、构造对象、运行时修改类定义
- 动态代理是方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，如包装RPC调用，面向切面编程
- 动态代码可以使用Java的反射实现，也可以字节码操作机制

#### 扩展

- 考察你对反射机制的了解和掌握程度。
- 动态代理解决了什么问题，在你业务系统中的应用场景是什么
- JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？

### int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。

- int是基础类型，Integer是对象
- -128-127之间

#### 扩展

- 我在专栏第 1 讲中介绍的 Java 使用的不同阶段：编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？
- 我在前面提到使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？
- 为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？
- 阅读过 Integer 源码吗？分析下类或某些方法的设计要点

### 对比 Vector、ArrayList、LinkedList 有何区别

- 都是有序集合，能对数据进行增伤改查
- LinkList基于双向链表实现；Vector、ArrayList基于数组进行实现，能动态进行扩容，Vector扩大1倍，而ArrayList扩大0.5倍
- Vector是线程安全的，其他两个不是

### 对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。

- 都是以键值对存储的数据类型
- hashtable是哈希表的实现，是线程安全的，不支持null
- hashMap和hashtable，但不是线程安全的，支持null
- TreeMap是基于红黑树实现的，get、put、remove都是O(logN)，不是线程安全的，支持null

#### 扩展

- 理解 Map 相关类似整体结构，尤其是有序数据结构的一些要点。
- 从源码去分析 HashMap 的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响 Map 的性能，实践中如何取舍等。
- 理解树化改造的相关原理和改进原因。

- 哈希值的有效性
  - equals 相等，hashCode 一定要相等。
  - 重写了 hashCode 也要重写 equals。
  - hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。
  - equals 的对称、反射、传递等特性。

### 如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全

- Java提供了同步包装器，使用函数进行包装即可，也就是方法加上synchronized修饰，缺点是粗粒度同步，性能低下，高并发下不能使用
- 并发包提供的线程安全容器类
  - 各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。
  - 各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。
  - 各种有序容器的线程安全版本等。

#### 扩展

- 理解基本的线程安全工具。
- 理解传统集合框架并发编程中 Map 存在的问题，清楚简单同步方式的不足。
- 梳理并发包内，尤其是 ConcurrentHashMap 采取了哪些方法来提高并发表现。
- 最好能够掌握 ConcurrentHashMap 自身的演进，目前的很多分析资料还是基于其早期版本。

### Java 提供了哪些 IO 方式？ NIO 如何实现多路复用

- 基于流模型实现，提供一些熟知的I/O功能，如文件、输入输出等；交互方式同步、阻塞方式；简单直观，容易成性能瓶颈
- 提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用、同步非阻塞I/O
- NIO2基于事件和回调，实现异步非阻塞I/O

#### 扩展

- 基础 API 功能与设计， InputStream/OutputStream 和 Reader/Writer 的关系和区别。
- NIO、NIO 2 的基本组成。给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。
- NIO 提供的高性能数据操作方式是基于什么原理，如何使用？
- 或者，从开发者的角度来看，你觉得 NIO 自身实现存在哪些问题？有什么改进的想法吗？

### Java 有几种文件拷贝方式？哪一种最高效

- io库：FileInputStream、FileOutputStream
- nio库：TransferTo、TransferFrom，利用了操作系统底层机制，避免不必要的拷贝和上下文切换，可能较快

#### 扩展

- 不同的 copy 方式，底层机制有什么区别？
- 为什么零拷贝（zero-copy）可能有性能优势？
- Buffer 分类与使用。
- Direct Buffer 对垃圾收集等方面的影响与实践选择。

### 谈谈接口和抽象类有什么区别

- interface：对行为的抽象，抽象方法的集合，利用他可以达到API定义和实现分离的目的；不能实例化；只能包含常量成员和静态方法/抽象方法
- abstract:抽取类的公共部分，利用继承达到代码复用的目的；不能实例化；成员和方法和一般类一样，没有其他限制

#### 扩展

- 对于 Java 的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。
- 在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在 review 代码的时候看出明显的不利于未来维护的设计。
- 掌握 Java 语言特性演进。现在非常多的框架已经是基于 Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。

- 多继承的实现，不用在接口中添加，可以使用实现静态工具类

## Java进阶

### synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？

- synchronized为Java內建的同步机制，提供互斥的语义和可见性，当一个线程获取当前锁时，其他线程尝试获取时会进入阻塞或等待
- ReentranLock再入锁，语义与synchronized基本相同；不同的是锁通过lock获取，所有需要注意锁的释放；代码书写比较灵活，如公平等
- 看应用场景，在低竞争的场景下前者可能更优

#### 扩展

- 理解什么是线程安全。
- synchronized、ReentrantLock 等机制的基本使用与案例。
- 掌握 synchronized、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念。
- 掌握并发包中 java.util.concurrent.lock 各种不同实现和案例分析。

### synchronized 底层如何实现？什么是锁的升级、降级？

- synchronized底层使用monitorenter/monitorexit实现，Monitor对象是基本的同步单元
- 重量级锁：依靠操作系统的互斥锁，进行用户态动内核态的切换；轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。
- 轻量级锁：如果有线程尝试获取偏斜锁的对象，则升级为轻量级锁
- 偏斜锁：假定初始没有竞争出现，当前对象偏向当前线程，大部分生命周期被一个线程锁定，使用偏斜锁降低竞争开销
- 当jvm进入安全点时，查看有没有闲置的monitor，有的话尝试进行降级
- 上面的三种级别的锁时jvm内部实现的，并不是应用代码控制，可以看做jvm一种代码优化，但效果还是要看实际情况

### 一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。

- 会报错，不予许两次调用
- 新建、就绪、等待、阻塞、超时等待、终止

#### 扩展

- 相对理论一些的面试官可以会问你线程到底是什么以及 Java 底层实现方式。
- 线程状态的切换，以及和锁等并发工具类的互动。
- 线程编程时容易踩的坑与建议等。

### 什么情况下 Java 程序会产生死锁？如何定位、修复？

- 两个或者多个线程相互持有对方需要的锁，导致进入永久循环的死锁状态
- jstack等工具获取线程栈，定位相互之间的依赖关系，找到死锁；程序员写的时候需要考虑周全

#### 扩展

- 抛开字面上的概念，让面试者写一个可能死锁的程序，顺便也考察下基本的线程编程。
- 诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用 API 实现吗？
- 后期诊断死锁还是挺痛苦的，经常加班，如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗？
  - 尽量使用一个锁
  - 设计好锁的获取顺序
  - 超时设置
  - 静态代码分析

### Java 并发包提供了哪些并发工具类？

- 提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。
- 各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。
- 各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。
- 强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。

### 并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？

- Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。
  - Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。
  - 但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。
  - 与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。
  - 弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。
  - 与此同时，读取的性能具有一定的不确定性。
- 而 LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。

#### 扩展

- 哪些队列是有界的，哪些是无界的？（很多同学反馈了这个问题）
  - ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如
  - LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。
  - ynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。
  - PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。
  - DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。
- 针对特定场景需求，如何选择合适的队列实现？
- 从源码的角度，常见的线程安全队列是如何实现的，并进行了哪些改进以提高性能表现？
  - 考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而 LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。
  - 从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。
  - 通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。
  - ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。
  - 如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照专栏上一讲的例子，你可能会选择 CountDownLatch，但是SynchronousQueue也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。
  - 可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。

### Java 并发类库提供的线程池有哪几种？ 分别有什么特点？

- newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。
- newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。
- newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。
- newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。
- newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。

#### 扩展

- 掌握 Executor 框架的主要内容，至少要了解组成与职责，掌握基本开发用例中的使用。
- 对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。
- 实践中有哪些常见问题，基本的诊断思路是怎样的。
  - 避免任务堆积。前面我说过 newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。
  - 避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的 HTTP/2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。
  - 另外，如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。
  - 避免死锁等同步问题，对于死锁的场景和排查，你可以复习专栏第 18 讲
  - 尽量避免在使用线程池时操作 ThreadLocal，同样是专栏第 17 讲已经分析过的，通过今天的线程池学习，应该更能理解其原因，工作线程的生命周期通常都会超过任务的生命周期。
- 如何根据自身应用特点合理使用线程池。
  - 如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。
  - 如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法

### AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？

- AtomicInteger是int的封装，提供原子性的访问和更新操作，其原子性操作基于CAS技术
- CAS：获取当前数值，利用CAS指令试图进行更新，如果没有改变，代码其他线程没有并发修改，则成功更新；否则进行重试或返回其他

### 扩展

- 在什么场景下，可以采用 CAS 技术，调用 Unsafe 毕竟不是大多数场景的最好选择，有没有更加推荐的方式呢？毕竟我们掌握一个技术，cool 不是目的，更不是为了应付面试，我们还是希望能在实际产品中有价值。
- 对 ReentrantLock、CyclicBarrier 等并发结构底层的实现技术的理解。

### 请介绍类加载过程，什么是双亲委派模型？

- 加载：字节码读取到jvm中
- 链接：
  - 验证：符合规范，安全
  - 准备：初始化静态变脸
  - 解析：将常量池中的符合引用替换为直接引用
- 初始化：执行代码逻辑，静态相关代码

- 加载尽量交给父加载器，目的是为了避免重复加载

- 启动类加载器、应用类加载器、扩展类加载器

### 有哪些方法可以在运行时动态生成一个 Java 类？

- 源码--class--ProcessBuilder启动javac-编译-类加载器加载

- 字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？
- 如何利用字节码操纵技术，实现基本的动态代理逻辑？
- 除了动态代理，字节码操纵技术还有那些应用场景？

### 谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？

- 方法区、堆、本地方法栈、程序计算器、虚拟机栈
- 处理程序计数器，都会发生上面的错误

### 如何监控和诊断 JVM 堆内和堆外内存使用？

- 命令行：jstat、jmap
- 图形化：JConsole、VisualVM

### Java 常见的垃圾收集器有哪些？

- Serial GC、ParNew GC、CMS（标记-清除）、Parallel GC、G1 GC（吞吐量和停顿时间）

### 谈谈你的 GC 调优思路？

- 理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。
- 掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。
- 这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。
- 通过分析确定具体调整的参数或者软硬件配置。
- 验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。

### Java 内存模型中的 happen-before 是什么？

- Java内存中保证多线程可见性的机制
- 语句执行、变量的写、锁、对象新建、线程启动

### Java 程序运行在 Docker 等容器环境有哪些新问题？

- 内存、线程、打包体积

### 后台服务出现明显“变慢”，谈谈你的诊断思路？

- CPU内存等、日志、GC、Profiling

### 谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？

- 隔离级别：数据库并发读写的正确性
- MySQL的事物隔离：基于MVCC和锁的复合实现
  - 读未提交:一个事务可以看到其他事务未提交的修改，运行脏读
  - 读已提交：一个事务看到的都是其他事务已提交的修改，没有脏读，但有不可重复读和幻象读
  - 可重复读：一个事务多次读取的数据是一致的，默认级别，不会出现幻象读
  - 串行化：并发事务之间是串行化的，最高级别

- 悲观锁：数据出现冲突的可能性更大
- 乐观锁：数据出现冲突的可能性小

### 谈谈 Spring Bean 的生命周期和作用域？

- 创建：
  - 实例化对象，设置属性，有依赖注入依赖，前置化初始化方法，如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法，自身init方法，后置初始化方法，完成
- 销毁：
  - 依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法。

- 作用域：
  - Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例。
  - Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例。
  - Request，为每个 HTTP 请求创建单独的 Bean 实例。
  - Session，很显然 Bean 实例的作用域是 Session 范围。
  - GlobalSession，用于 Portlet 容器，因为每个 Portlet 有单独的 Session，GlobalSession 提供一个全局性的 HTTP Session。

### 对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？

- 更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。
- 充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。
- 使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。
- 在通信协议、序列化等其他角度的优化。

### 谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？

- 基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。
- 基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。这是目前应用相对比较广泛的一种方式，其结构定义你可以参考下面的示意图。
- Redis、ZooKeeper、MongoDB 等中间件，也都有各种唯一 ID 解决方案。其中一些设计也可以算作是 Snowflake 方案的变种。例如，MongoDB 的ObjectId提供了一个 12 byte（96 位）的 ID 定义，其中 32 位用于记录以秒为单位的时间，机器 ID 则为 24 位，16 位用作进程 ID，24 位随机起始的计数序列。
- 国内的一些大厂开源了其自身的部分分布式 ID 实现，InfoQ 就曾经介绍过微信的seqsvr，它采取了相对复杂的两层架构，并根据社交应用的数据特点进行了针对性设计，具体请参考相关代码实现。另外，百度、美团等也都有开源或者分享了不同的分布式 ID 实现，都可以进行参考。

- 我认为没有影响，你可以从 Snowflake 的具体算法实现寻找答案。我们知道 Snowflake 算法的 Java 实现，大都是依赖于 System.currentTimeMillis()，这个数值代表什么呢？从 Javadoc 可以看出，它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个数值与夏 / 冬令时并没有关系，所以并不受其影响。