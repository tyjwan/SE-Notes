# 子数组、子序列类型题目算法记录
***
*参考书目《程序员代码面试指南》--左程云：下面只是用自己的语言记录下其思想，具体请看书*

### 1.数组生成窗口最大值
&ensp;&ensp;&ensp;&ensp;本题一个最重要的就是滑动窗口滚动的更新技巧：为窗口创建最大值队列，在队列首部永远是窗口中的最大值，没次加入新的数值时首先检查队首元素是否过期和更新队列的值

### 2.最大值减去最小值等于N的子数组数量
&ensp;&ensp;&ensp;&ensp;本题也是应用了滑动窗口的队列技巧：求出每个以i开头的子数组的最大值和最小值，用最小维护队列和最大维护队列获得。子数组向前扩展时不满足条件既停止开始下一轮。

### 3.最长递增子序列（不连续）
&ensp;&ensp;&ensp;&ensp;举例

    arr = [2,1,5,3,6,4,8,9,7],返回的最长递增子序列为[1,3,4,8,9]

&ensp;&ensp;&ensp;&ensp;第一种时间复杂度为O(N^2)的方法：计算数组中以位置i结尾的最长子数组序列，其结果用dp[]进行保存。在计算中需要注意的是如果当前位置的值小于i的值，则序列长度等于当前位置的最长长度+1，如果比当前i的值大，则更新dp[]的值。大于i的值则什么都不做，伪代码如下

```c++
for i=0 i<arr.length i++ //计算没有以i位置结尾的最长序列
    for j=0 j<i j++
        //如果当前数小于结尾数并且长度+1以后大于原来的序列长度，更新
        if arr[i] > arr[j]
            dp[i] = max(dp[j]+1, dp[i])
```

&ensp;&ensp;&ensp;&ensp;另一种是时间复杂度为O(N*logN)的方法，其应用了二分的思想来降低时间复杂度，其既在计算dp[]的时候应用二分来使建立dp[]的时间降低。其中是建立一个end数组用来存储遍历过程中的从小到大的排列的数，而dp的值也就是他的长度。

```c++
l = 0;
r = 0;
m = 0;
right = 0;
for(int i=0; i<arr.length; i++) {
    l = 0;
    r = right;
    while(l <= r) {
        m = (l+r)/2;
        if(arr[i] > ends[m]) {
            l = m+l;
        }
        else {
            r= m -1;
        }
    }
    right = max(right, l);
    ends[l] = arr[i];
    dp[i] = l+1;
}
```

### 4.最长公共子序列（不连续）、子串（连续）问题
&ensp;&ensp;&ensp;&ensp;使用动态规划求解，在不连续的情况下，注意在初始化第一行和第一列中如果有一个值为1，那么后面的的也唯一，而在连续的情况下只是它自己，不影响后面的。在不连续的情况下dp的值取左边、上边和如果相等时左上角+1的最大值；在连续的情况下只与左上角有关

&ensp;&ensp;&ensp;&ensp;在要求打印出子序列的不连续的情况下：
- 1.大于左方和上方，向左上移动
- 2.等于的向左和向上都行
- 3.只等于上方，向上移动
- 4.只等于左方，向左移动

&ensp;&ensp;&ensp;&ensp;在连续的情况下，找到最大的位置后一路向左上方移动即可

### 5.需要排序的最短子数组长度
&ensp;&ensp;&ensp;&ensp;这个是个技巧吧：首先从右到左遍历数组，记录和更新出现的最小值min和其位置minPos，如果到后面minPos依旧是-1，就说明数组是有序的，当出现当前数大于最小值的情况说明就是这个数破坏了序列，一直更新下去找到最左边的破坏的位置；再从左往右遍历，记录和更新出现的最大值和其位置maxPos，和上面的类似，举一反三就行了。最后minPos和maxPos就是需要排序的最短子数组了

### 6.未排序数组中累加和为给定值的最长子数组长度
&ensp;&ensp;&ensp;&ensp;在只有正数的情况下：这个题的思想和技巧还是挺牛的：用left和right标记累加区间，len随时记录和更新，sum随时记录和更新区间的值。当sum等于给定值的时候就比较更新len并且左区间向右移动一位，更新sum；当sum小于给定值的时候右区间向右移动一位，sum更新；当sum大于给定值时，左区间向右移动一位，更新sum；

&ensp;&ensp;&ensp;&ensp;在有正有负有0的情况下：这个需要一些改变，利用当前的累加和-过程的累加和是否等于给定值来求解。需要注意的是0的位置是-1，并且用一个map保存下sum值最早出现的位置。其还有很多变种，如0、1问题之类，举一反三即可。

### 7.子数组的最大累加和问题
&ensp;&ensp;&ensp;&ensp;使用max记录并更新最大值，cur从头累加到尾部，并每一步都比较更新max，当cur小于0的时候cur重置为0，不更新max的值

### 8.子数组的最大累乘积问题
&ensp;&ensp;&ensp;&ensp;此问题和最长递增子序列类似，求成每个以i结尾的dp，但这个不同的是最大有三种情况：

- 1.是前个位置的最大乘与当前值
- 2.是前个位置的最小乘与当前值
- 3.只是当前值

&ensp;&ensp;&ensp;&ensp;按照这个生成一般dp即可。这个给我们一些关于乘积的启示：因为负负得正的情况，需要同时需要最大值和最小值

### 9.单调栈类型问题
&ensp;&ensp;&ensp;&ensp;这个是使用与那种，求子数组中与最大值最小值相关的求和或其他类似的问题，就好像头条的问提，用这个方法直接O(N)就解决了。✈️🚀✈️🚀✈️


